from typing import Any, Optional
import time
import logging

# --- assumes these are defined elsewhere in your module ---
# async def make_nws_request(url: str) -> Optional[dict[str, Any]]: ...
# def format_alert(feature: dict) -> str: ...
# logger = logging.getLogger(...)
# US_STATE_CODES = {...}
# _NWS_CACHE, _get_cached, _set_cache, _fetch_nws_with_cache as earlier
# NWS_API_BASE = "https://api.weather.gov"
# --------------------------------------------------------

@mcp.tool()
async def get_alerts(state: str, *, ttl: int = 300) -> dict[str, Any]:
    """
    Get weather alerts for a US state (structured JSON).

    Returns a dict with:
      - status: "ok" or "error"
      - state: canonical two-letter code
      - count: number of alerts
      - alerts: list of structured alert dicts
      - alerts_text: list of human-readable alert strings (same order)
      - raw: raw NWS JSON payload for debugging/traceability
      - message: explanatory message on error or edge cases
    """
    if not isinstance(state, str):
        return {"status": "error", "message": "Invalid state code type; expected string."}

    code = state.strip().upper()
    if len(code) != 2 or code not in US_STATE_CODES:
        return {"status": "error", "message": f"Invalid US state code: '{state}'. Use a two-letter postal code (e.g., CA, NY)."}

    url = f"{NWS_API_BASE}/alerts/active/area/{code}"
    logger.info("Fetching state alerts: %s (TTL=%ss)", url, ttl)
    data = await _fetch_nws_with_cache(url, ttl=ttl)

    if data is None:
        return {"status": "error", "state": code, "message": "Unable to fetch alerts (network or upstream failure)."}

    features = data.get("features")
    if features is None:
        return {"status": "ok", "state": code, "count": 0, "alerts": [], "alerts_text": [], "raw": data,
                "message": "No alert information returned by NWS."}

    if not features:
        return {"status": "ok", "state": code, "count": 0, "alerts": [], "alerts_text": [], "raw": data,
                "message": f"No active alerts for {code}."}

    structured_alerts: list[dict[str, Any]] = []
    text_alerts: list[str] = []

    for feature in features:
        fid = feature.get("id")
        props = feature.get("properties", {})

        # Structured representation
        s = {
            "id": fid,
            "event": props.get("event"),
            "headline": props.get("headline"),
            "areaDesc": props.get("areaDesc"),
            "severity": props.get("severity"),
            "certainty": props.get("certainty"),
            "urgency": props.get("urgency"),
            "senderName": props.get("senderName"),
            "onset": props.get("onset"),
            "ends": props.get("ends"),
            "description": props.get("description"),
            "instruction": props.get("instruction"),
            "parameters": props.get("parameters"),  # may be None or dict
        }

        structured_alerts.append(s)
        # Human-friendly text (keeps the earlier format)
        text_alerts.append(format_alert(feature))

    return {
        "status": "ok",
        "state": code,
        "count": len(structured_alerts),
        "alerts": structured_alerts,
        "alerts_text": text_alerts,
        "raw": data,
    }


@mcp.tool()
async def get_forecast(latitude: float, longitude: float, *, periods: int = 5, ttl: int = 300) -> dict[str, Any]:
    """
    Get weather forecast for a location (structured JSON).

    Returns a dict with:
      - status: "ok" or "error"
      - lat, lon
      - point_url, forecast_url
      - location (if available)
      - periods_returned: number actually returned
      - periods: list of structured period objects (name, startTime, endTime, temp, unit, wind, short/detailed)
      - raw: raw forecast JSON
      - message: explanatory message on error or edge cases
    """
    # validate numeric inputs
    try:
        lat = float(latitude)
        lon = float(longitude)
    except (TypeError, ValueError):
        return {"status": "error", "message": "Invalid latitude/longitude: numeric values required."}

    if not (-90.0 <= lat <= 90.0 and -180.0 <= lon <= 180.0):
        return {"status": "error", "message": "Latitude must be -90..90 and longitude -180..180."}

    periods = int(periods) if periods and int(periods) > 0 else 5
    logger.info("Fetching forecast for %f,%f (periods=%d, ttl=%ds)", lat, lon, periods, ttl)

    points_url = f"{NWS_API_BASE}/points/{lat},{lon}"
    points_data = await _fetch_nws_with_cache(points_url, ttl=ttl)
    if points_data is None:
        return {"status": "error", "lat": lat, "lon": lon, "message": "Unable to fetch point metadata from NWS."}

    props = points_data.get("properties", {})
    # Prefer 'forecast' (periods), fallback to other endpoints.
    forecast_url = props.get("forecast") or props.get("forecastHourly") or props.get("forecastGridData")
    if not forecast_url:
        return {"status": "error", "lat": lat, "lon": lon, "message": "No forecast endpoint available for that location.", "point": props}

    forecast_data = await _fetch_nws_with_cache(forecast_url, ttl=ttl)
    if forecast_data is None:
        return {"status": "error", "lat": lat, "lon": lon, "forecast_url": forecast_url, "message": "Unable to fetch forecast data."}

    fprops = forecast_data.get("properties", {})
    periods_list = fprops.get("periods")
    if not isinstance(periods_list, list):
        # If NWS returned a grid or unfamiliar shape, return raw payload and advise the caller.
        return {
            "status": "ok",
            "lat": lat,
            "lon": lon,
            "point_url": points_url,
            "forecast_url": forecast_url,
            "periods_returned": 0,
            "periods": [],
            "raw": forecast_data,
            "message": "Forecast payload did not include 'periods' list. Use forecastHourly or examine raw payload."
        }

    # Build structured periods
    out_periods: list[dict[str, Any]] = []
    for p in periods_list[:periods]:
        entry = {
            "id": p.get("number"),
            "name": p.get("name"),
            "startTime": p.get("startTime"),
            "endTime": p.get("endTime"),
            "temperature": p.get("temperature"),
            "temperatureUnit": p.get("temperatureUnit"),
            "windSpeed": p.get("windSpeed"),
            "windDirection": p.get("windDirection"),
            "shortForecast": p.get("shortForecast"),
            "detailedForecast": p.get("detailedForecast"),
            "isDaytime": p.get("isDaytime"),
        }
        out_periods.append(entry)

    # Try to extract a friendly location name
    rel_loc = props.get("relativeLocation")
    location_name = None
    if isinstance(rel_loc, dict):
        location_name = rel_loc.get("properties", {}).get("city")
        region = rel_loc.get("properties", {}).get("state")
        if region:
            location_name = f"{location_name}, {region}" if location_name else region

    return {
        "status": "ok",
        "lat": lat,
        "lon": lon,
        "point_url": points_url,
        "forecast_url": forecast_url,
        "location": location_name,
        "periods_returned": len(out_periods),
        "periods": out_periods,
        "raw": forecast_data,
    }
